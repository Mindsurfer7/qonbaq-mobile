# Инструкция для ИИ: как не вносить баги при парсинге JSON в Flutter/Dart

## Контекст проблемы (что уже ломало приложение)
- Бэкенд **часто отдаёт вложенные объекты в “коротком” виде** (например, `template` внутри `approval` без `createdAt/updatedAt`, без `businessId`, и т.п.).
- Если в `fromJson` делать жёсткие касты вида `json['x'] as String` или `DateTime.parse(json['createdAt'] as String)`, то при `null` будет рантайм‑крэш:
  - `type 'Null' is not a subtype of type 'String' in type cast`
- Такие крэши **ошибочно отображаются пользователю как “ошибка сети/серверная ошибка”**, хотя HTTP 200 и данные приходят.

## Правила (обязательные)
1. **Никогда не кастуй потенциально null поле как non‑null**:
   - Плохо: `json['createdAt'] as String`
   - Хорошо: `final s = json['createdAt'] as String?;`
2. **Дата/время**:
   - Если поле может отсутствовать в “коротких” DTO (часто `createdAt/updatedAt`), делай null‑safe:
     - `createdAt: s != null ? DateTime.parse(s) : DateTime.fromMillisecondsSinceEpoch(0, isUtc: true)`
3. **Вложенные объекты**:
   - Считай, что вложенный объект может быть “коротким” и не содержать всех полей.
   - `fromJson` вложенной модели должен уметь парсить “короткий” вариант (иначе падает весь список).
4. **Списки/контейнеры**:
   - Эндпоинт может вернуть `{data: [...]}`, `{items: [...]}`, `{approvals: [...]}`, либо просто `[...]`.
   - Парсинг должен поддерживать эти варианты без крэша.
5. **Ошибки**:
   - Ошибки формата данных (парсинг) **не маскировать как network error**.
   - Если надо — бросай `FormatException` с понятным сообщением (без “Ошибка сети”).
6. **UI при частичных ошибках** (когда 2+ запросов для одного экрана):
   - Не показывать фатальную ошибку, если **хотя бы часть данных успешно загружена**.
   - Ошибку можно показать как non‑blocking (SnackBar/баннер), но не скрывать данные.

## Чек‑лист перед коммитом
- Я проверил все `fromJson` на:
  - `... as String` для полей, которые могут быть null/отсутствовать
  - `DateTime.parse(json['...'] as String)` без null‑check
  - вложенные объекты (`template`, `sender`, `business`, `assignee`, …), которые бэкенд может отдавать “коротко”
- Я убедился, что экран **не показывает “ошибка” при HTTP 200**, если данные пришли.
- Я убрал отладочные `print` (или обернул в debug‑флаги), чтобы не загрязнять прод‑логи.

## Рекомендуемый подход (чтобы было единообразно)
- Используй небольшие helper‑функции/extension для чтения JSON (например, `lib/core/utils/json_read.dart`), чтобы:
  - централизованно решать null‑safe парсинг
  - выдавать одинаковые `FormatException` с контекстом


